---
// src/layouts/GeometricText.astro

export interface Props {
  text: string;
  colors: string[];
}

const { text, colors } = Astro.props;

const skyColors = colors.slice(0, 4);
const groundColors = colors.slice(4, 6);

// RGB to HSL変換
function rgbToHsl(hex: string): [number, number, number] {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0, s = 0, l = (max + min) / 2;

  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    
    switch(max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return [h * 360, s * 100, l * 100];
}

// HSL to RGB変換
function hslToRgb(h: number, s: number, l: number): string {
  h = h / 360;
  s = s / 100;
  l = l / 100;

  let r, g, b;

  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  const toHex = (x: number) => {
    const hex = Math.round(x * 255).toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  };

  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

function blendColorsHsl(skyColor: string, groundColor: string, ratio: number = 0.5): string {
  const [hSky, sSky, lSky] = rgbToHsl(skyColor);
  const [hGround, sGround, lGround] = rgbToHsl(groundColor);

  // 色相のブレンド（360度を考慮した補間）
  let hDiff = hGround - hSky;
  if (hDiff > 180) hDiff -= 360;
  if (hDiff < -180) hDiff += 360;
  const h = (hSky + hDiff * ratio + 360) % 360;

  // 彩度のブレンド
  const s = sSky + (sGround - sSky) * ratio;

  // 明度の調整（コントラスト比を考慮）
  const baseLightness = lSky + (lGround - lSky) * ratio;
  const averageLightness = (lSky + lGround) / 2;
  let l = baseLightness;
  
  if (baseLightness < averageLightness) {
    l = Math.min(baseLightness + (100 - baseLightness) * 0.7, 90);
  } else {
    l = Math.max(baseLightness * 0.3, 15);
  }

  return hslToRgb(h, s, l);
}

const baseColor = blendColorsHsl(skyColors[2], groundColors[0], 0.2);
const patternColors = [
  blendColorsHsl(skyColors[0], groundColors[0], 0.3),
  blendColorsHsl(skyColors[0], groundColors[1], 0.7),
  blendColorsHsl(skyColors[1], groundColors[0], 0.4),
  blendColorsHsl(skyColors[1], groundColors[1], 0.6),
  blendColorsHsl(skyColors[2], groundColors[0], 0.45),
  blendColorsHsl(skyColors[2], groundColors[1], 0.55),
  blendColorsHsl(skyColors[3], groundColors[0], 0.35),
  blendColorsHsl(skyColors[3], groundColors[1], 0.65)
];

function generateOrganicPaths(width: number, height: number): string[] {
  const paths: string[] = [];
  const numDivisions = Math.min(Math.max(6, Math.floor(Math.random() * 10) + 8), 16); // 6-16個に増加
  
  // ボロノイ図のような分割点をランダムに生成
  const generatePoints = (n: number): [number, number][] => {
    const points: [number, number][] = [];
    for (let i = 0; i < n; i++) {
      // より広い範囲に分布
      points.push([
        width * (0.1 + Math.random() * 0.8),  // 10%-90%の範囲で分布
        height * (0.1 + Math.random() * 0.8)
      ]);
    }
    return points;
  };

  // 多角形の頂点を生成
  const createPolygon = (center: [number, number]): [number, number][] => {
    const vertices: [number, number][] = [];
    const numVertices = Math.floor(Math.random() * 3) + 3; // 3-5角形
    const baseRadius = Math.min(width, height) * 0.25; // サイズを25%に拡大
    
    for (let i = 0; i < numVertices; i++) {
      const angle = (2 * Math.PI * i) / numVertices + Math.random() * 0.5 - 0.25;
      const radius = baseRadius * (0.8 + Math.random() * 0.4);
      vertices.push([
        center[0] + radius * Math.cos(angle),
        center[1] + radius * Math.sin(angle)
      ]);
    }
    return vertices;
  };

  // 分割点を生成し、各点を中心とした多角形を作成
  const centers = generatePoints(numDivisions);
  centers.forEach(center => {
    const vertices = createPolygon(center);
    const path = `
      M ${vertices[0][0]},${vertices[0][1]}
      ${vertices.slice(1).map(([x, y]) => `L ${x},${y}`).join(' ')}
      L ${vertices[0][0]},${vertices[0][1]}
      Z
    `;
    paths.push(path.trim());
  });

  return paths;
}

const maskId = `text-mask-${Math.random().toString(36).substring(7)}`;
const patternId = `pattern-${Math.random().toString(36).substring(7)}`;
const organicPaths = generateOrganicPaths(60, 48);
---

<div class="relative py-1">
  <svg class="w-full h-12" viewBox="0 0 400 48" preserveAspectRatio="xMidYMid meet">
    <defs>
      <pattern
        id={patternId}
        patternUnits="userSpaceOnUse"
        width="60"
        height="48"
        patternTransform="scale(1.2) rotate(15)"
      >
        <!-- ベース背景 -->
        <rect width="60" height="48" fill={baseColor} />
        
        <!-- 有機的なパターン -->
        {organicPaths.map((path, index) => (
          <path
            d={path}
            fill={patternColors[index % patternColors.length]}
            opacity="0.8"
          >
            <animate
              attributeName="d"
              dur={`${15 + index * 3}s`}
              repeatCount="indefinite"
              values={`${path};${generateOrganicPaths(60, 48)[index]};${path}`}
            />
          </path>
        ))}
      </pattern>

      <mask id={maskId}>
        <text
          x="50%"
          y="50%"
          text-anchor="middle"
          dominant-baseline="middle"
          fill="white"
          class="text-2xl font-bold font-inter"
        >
          {text}
        </text>
      </mask>
    </defs>

    <rect
      width="100%"
      height="100%"
      fill={`url(#${patternId})`}
      mask={`url(#${maskId})`}
    />
  </svg>
</div>

<style>
  text {
    font-size: 2rem;
    font-weight: bold;
  }
</style>